@startuml
-> AdvisedSupport : getInterceptorsAndDynamicInterceptionAdvice()
activate AdvisedSupport #DarkSalmon

note left of AdvisedSupport #FAEBD7
    *介绍获得要织入的横切逻辑调用链
    ---这里只描述了主要步骤
end note
    alt 缓存获取不到时，才重新组装
        AdvisedSupport -> DefaultAdvisorChainFactory : getInterceptorsAndDynamicInterceptionAdvice()
        activate DefaultAdvisorChainFactory #DarkSalmon
            DefaultAdvisorChainFactory -> DefaultAdvisorChainFactory : hasMatchingIntroductions()：确定是否存在匹配的IntroductionAdvisor
            activate DefaultAdvisorChainFactory #DarkSalmon
            deactivate DefaultAdvisorChainFactory

            loop Advisor advisor : config.getAdvisors()
                note right of DefaultAdvisorChainFactory #aqua
                    获取能用在当前方法织入逻辑Interceptor，添加到返回横切逻辑调用链中
                        ---注意有可能把MethodInterceptor转换成InterceptorAndDynamicMethodMatcher
                            视MethodMatcher.isRuntime()来决定
                end note

                alt advisor是PointcutAdvisor类型实例
                    DefaultAdvisorChainFactory -> DefaultAdvisorAdapterRegistry :getInterceptors()
                    activate DefaultAdvisorAdapterRegistry #DarkSalmon
                        note right of DefaultAdvisorAdapterRegistry #aqua
                            获取advisor中的MethodInterceptor，不同类型的Advisor由xxxAdvisorAdapter来协助把内部Advice转换成统一的MethodInterceptor
                                AfterReturningAdviceAdapter -> AfterReturningAdvice -> AfterReturningAdviceInterceptor -> MethodInterceptor
                                MethodBeforeAdviceAdapter -> MethodBeforeAdvice -> MethodBeforeAdviceInterceptor -> MethodInterceptor
                                ThrowsAdviceAdapter -> ThrowsAdvice -> ThrowsAdviceInterceptor -> MethodInterceptor

                        end note
                    DefaultAdvisorAdapterRegistry --> DefaultAdvisorChainFactory :MethodInterceptor[] interceptors
                    deactivate DefaultAdvisorAdapterRegistry

                    DefaultAdvisorChainFactory -> MethodMatchers :matches()
                    activate MethodMatchers #DarkSalmon
                        note right of MethodMatchers #aqua
                            最终委托MethodMatcher实现类来匹配，注意里面对IntroductionAwareMethodMatcher和
                            普通MethodMatcher分开处理的。
                        end note
                    MethodMatchers --> DefaultAdvisorChainFactory :boolean
                    deactivate MethodMatchers

                else advisor是IntroductionAdvisor类型实例
                    note right of DefaultAdvisorAdapterRegistry #aqua
                        确定当前PointcutAdvisor适用该Class类型：如有必要只进行类型匹配
                    end note
                else 默认处理行为
                    note right of DefaultAdvisorAdapterRegistry #aqua
                        默认当前advisor的Intercepter都是适用的
                    end note
                end


            end

        DefaultAdvisorChainFactory --> AdvisedSupport : getInterceptorsAndDynamicInterceptionAdvice()
        deactivate DefaultAdvisorChainFactory

    end

<-- AdvisedSupport: List<Object>，其中Object类型为MethodInterceptor
deactivate AdvisedSupport

note right of AdvisedSupport #FAEBD7
*总结
    1.确定是否存在匹配的IntroductionAdvisor，并适用该类，此时在for循环前调用，避免在后面for循环重复运行
    2.我们发现相应不管是前置，后置，异常通知，都能转换成MethodInterceptor的形式，便于框架统一的方式处理
    3.通过MethodMatcher.isRuntime来确定是否是DynamicMethodMather类型，是则需要包装成InterceptorAndDynamicMethodMatcher

*备注
    1.IntroductionAdvisor: 只运用于类级别的拦截，只能用于Introduction型的Advice
    2.PointcutAdvisor: 运用任何类型的Pointcut，差不多任何类型的Advice
    3.Advised.preFiltered：用于跳过ClassFilter.matches
    4.MethodMatcher.isRuntime：
        false: 当前是StaticMethodMatcher类型，不考虑方法入参
        true: 当前是DynamicMethodMatcher类型，考虑方法入参
end note

@enduml