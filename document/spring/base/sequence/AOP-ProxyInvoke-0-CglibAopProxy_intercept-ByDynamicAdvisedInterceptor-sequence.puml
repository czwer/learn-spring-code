@startuml

autonumber

-> proxyObject: 代理对象方法调用

note right of proxyObject #FAEBD7
    *介绍CglibAopProxy生成的代理类，执行方法的调用过程
        ---这里只描述了主要步骤
        ---这个是常用的
     单元测试参：CglibProxyTests
end note
activate proxyObject #DarkSalmon

    proxyObject -> DynamicAdvisedInterceptor : intercept()
    activate DynamicAdvisedInterceptor #DarkSalmon

        note right of DynamicAdvisedInterceptor #aqua
            获得匹配当前方法的织入逻辑调用链。
        end note

        DynamicAdvisedInterceptor -> AdvisedSupport: getInterceptorsAndDynamicInterceptionAdvice()
        activate AdvisedSupport #DarkSalmon
        AdvisedSupport --> DynamicAdvisedInterceptor : chain
        deactivate AdvisedSupport

        alt 没有调用链，及public方法
            note right of DynamicAdvisedInterceptor #FF5000
                直接反射调用。
            end note

            DynamicAdvisedInterceptor -> MethodProxy: invoke()
            activate MethodProxy #DarkSalmon
            MethodProxy --> DynamicAdvisedInterceptor : chain
            deactivate MethodProxy

        else

            note right of DynamicAdvisedInterceptor #aqua
                把上下文信息包装成CglibMethodInvocation。
            end note

            DynamicAdvisedInterceptor -> CglibMethodInvocation : proceed()
            activate CglibMethodInvocation #DarkSalmon
                CglibMethodInvocation -> ReflectiveMethodInvocation : proceed()，实际调用父类中方法
                activate ReflectiveMethodInvocation #DarkSalmon
                    note right of ReflectiveMethodInvocation #FF5000
                        1.这里和JDK动态代理运行时共用同样的逻辑。
                        2.在最终调用目标方法时使用CglibMethodInvocation.invokeJoinpoint(),
                            以提高性能
                    end note
                CglibMethodInvocation --> ReflectiveMethodInvocation
                deactivate ReflectiveMethodInvocation
            CglibMethodInvocation --> DynamicAdvisedInterceptor
            deactivate CglibMethodInvocation
        end

    DynamicAdvisedInterceptor --> proxyObject : result
    deactivate DynamicAdvisedInterceptor


<-- proxyObject : result
deactivate proxyObject

note right of proxyObject #FAEBD7
*总结
    1.生成代理时：通过把要织入的业务逻辑放入到Callback与Cglib技术整合；
        ---这是在生成代理对象时做好了，
    2.代理对象执行时：把当前Callback(实际是DynamicAdvisedInterceptor)转换为CglibMethodInvocation，
        而CglibMethodInvocation本身是ReflectiveMethodInvocation子类，所以我们可以直接调用
        ReflectiveMethodInvocation.proceed()方法，达到和JDK动态代理一样的方式共享Spring AOP
        框架基础设施，运行并返回结果。
        ---注意这只是Cglib动态代理一种调用方式
    3.缓存在获取织入逻辑调用链发挥了重要作用，提高了性能
end note
@enduml