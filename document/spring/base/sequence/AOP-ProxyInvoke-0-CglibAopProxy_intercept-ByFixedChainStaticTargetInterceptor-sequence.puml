@startuml

autonumber

-> proxyObject: 代理对象方法调用

note right of proxyObject #FAEBD7
    *介绍CglibAopProxy生成的代理类，执行方法的调用过程
        ---这里只描述了主要步骤
        ---CglibAopProxy.DynamicAdvisedInterceptor这个内部类更常用
     单元测试参：CglibProxyTests
end note
activate proxyObject #DarkSalmon

    proxyObject -> FixedChainStaticTargetInterceptor : intercept()
    activate FixedChainStaticTargetInterceptor #DarkSalmon
        note right of FixedChainStaticTargetInterceptor #aqua
            把上下文信息包装成CglibMethodInvocation。
        end note

        FixedChainStaticTargetInterceptor -> CglibMethodInvocation : proceed()
        activate CglibMethodInvocation #DarkSalmon
            CglibMethodInvocation -> ReflectiveMethodInvocation : proceed()，实际调用父类中方法
            activate ReflectiveMethodInvocation #DarkSalmon
                note right of ReflectiveMethodInvocation #FF5000
                    1.这里和JDK动态代理运行时共用同样的逻辑。
                    2.在最终调用目标方法时使用CglibMethodInvocation.invokeJoinpoint(),
                        以提高性能
                end note
            CglibMethodInvocation --> ReflectiveMethodInvocation
            deactivate ReflectiveMethodInvocation
        CglibMethodInvocation --> FixedChainStaticTargetInterceptor
        deactivate CglibMethodInvocation


    FixedChainStaticTargetInterceptor --> proxyObject : result
    deactivate FixedChainStaticTargetInterceptor


<-- proxyObject : result
deactivate proxyObject

note right of proxyObject #FAEBD7
*总结
    1.生成代理时：通过把要织入的业务逻辑放入到Callback与Cglib技术整合；
        ---这是在生成代理对象时做好了，
    2.代理对象执行时：把当前Callback(实际是FixedChainStaticTargetInterceptor)转换为CglibMethodInvocation，
        而CglibMethodInvocation本身是ReflectiveMethodInvocation子类，所以我们可以直接调用
        ReflectiveMethodInvocation.proceed()方法，达到和JDK动态代理一样的方式共享Spring AOP
        框架基础设施，运行并返回结果。
        ---FixedChainStaticTargetInterceptor不需要重新获取织入逻辑调用链，是其优点
        ---注意这只是Cglib动态代理一种调用方式
end note

@enduml